# Projeto Ciclo de vida de uma Activity ü§≥
Ol√°!
Somos um grupo de alunos da Faculdade Nova Roma Campus Recife :))

Estamos criando esse projeto com intuito de destrinchar, explicar e exemplificar o conceito de maior
base em uma aplica√ß√£o android 
<br/>
üåü A Activity e seu ciclo de vida üåü

Ela se destaca como um pilar central, desempenhando um papel crucial na cria√ß√£o de interfaces de 
usu√°rio interativas. <br/>

## SUM√ÅRIO:

1. Introdu√ß√£o 
2. M√©todos e estados do ciclo de vida 
3. Navega√ß√£o entre activities 
4. Como ocorre o gerenciamento de estados em uma activity - salvando e restaurando esse estado
5. Melhores pr√°ticas - Uso de Fragments para uma gest√£o flex√≠vel de UI
6. Monitoramento via LogCat da sobrescrita dos m√©todos do ciclo de vida para an√°lise em um aplicativo real
7. Conclus√£o
8. Refer√™ncias de estudo

<br>

## Apresenta√ß√£o

### Quem Somos n√≥s?

Este grupo √© composto pelos alunos:

Raissa Maria Silva Barata Pereira ‚ú®
- E-mail: raissamaria.sb@gmail.com
- [LinkedIn](https://www.linkedin.com/in/raissa-barata-pereira)
- [GitHub](https://github.com/RaissaMariaB)
<br>

Laila Maria Silva Pereira ‚ú®
- E-mail: lailamaria.sp@gmail.com
- [LinkedIn](https://www.linkedin.com/in/laila-pereira-a171a224a/)
- [GitHub](https://github.com/LailaPereira)
<br>

Dyeggo Bezerra ‚ú®
- E-mail: dyeggo0201@gmail.com
- [LinkedIn](https://www.linkedin.com/in/dyeggo-bezerra-0518211b1/)
- [GitHub](https://github.com/dyeggoSilva)
  <br>


## Introdu√ß√£o

Se fossemos trazer de uma forma muito resumida, poder√≠amos dizer que uma activity √© uma tela,
onde temos os componentes de texto, bot√µes, menus, entre outros.

Mas para uma activity estar completa ela precisa ser composta pela combina√ß√£o de uma classe Kotlin dentro de um arquivo Kotlin,
e tamb√©m de um arquivo XML.
A combina√ß√£o desses dois forma uma activity e n√≥s usamos essa tela, (traduzindo livremente para "atividade") para fazer algo
que envolva a intera√ß√£o do usu√°rio
A pesar de ser poss√≠vel criar um arquivo sem o outro, n√£o √© algo rotineiro nem usual de ser feito.
<br/>
<img src='./assets/activity1.png '>
<br/>
üëâ Dica! Como boas pr√°tica na nomenclatura de uma activity, colocamos o nome activity ao fim. 
Ex: DetalhesActivity

Um aplicativo pode ter v√°rias Activities para diferentes prop√≥sitos, como por exemplo criar um email ou ler um email.
E apesar de operarem de forma independente, elas trabalham juntas para formar a experi√™ncia do usu√°rio.
O gerenciamento eficaz do ciclo de vida de uma Activity permite que os aplicativos se comportem de
maneira previs√≠vel durante eventos como rota√ß√µes de tela, garantindo que o
estado do aplicativo seja mantido de forma consistente.

#### Quais configura√ß√µes podemos colocar quando criamos uma activity?


<img src='./assets/configurations.png '>


- O primeiro campo Define o nome da sua activity. Como foi citado anteriormente, temos como
pr√°tica manter o nome activity no fim.
- A primeira marca√ß√£o de checkBox indica que vamos criar nosso arquivo de layout XML em conjunto.
- O campo "layout name" indica o nome desse arquivo de layout que est√° sendo criado.
- O segundo checkBox com "Launcher Activity", indica que essa ser√° a primeira activity 
chamada para a abertura do seu aplicativo.
- No dropdown de "package name" podemos selecionar o local do dosso projeto onde aquela activity ser√° criada.
- A campo de source language permite a escolha da linguagem a ser utilizada, pois em um projeto android, pode ser kotlin e/ou java.


## M√©todos e estados do ciclo de vida
O ciclo de vida de uma Activity no Android √© um conjunto de estados pelos quais a Activity passa 
desde o momento de sua cria√ß√£o at√© sua destrui√ß√£o. Esses estados s√£o gerenciados por callbacks que 
o sistema chama, permitindo que o desenvolvedor saiba qual estado a Activity est√° e prepare a 
aplica√ß√£o para executar certas a√ß√µes. Entender como as Activities s√£o criadas, pausadas, 
retomadas e destru√≠das √© cruacial para criar uma navega√ß√£o eficiente.


<img src='./assets/ciclodevida.png '>


#### Detalhando os m√©todos
- onCreate(): Inicializa uma activity
No primeiro momento quando abrimos uma aplica√ß√£o, ocorre a execu√ß√£o do m√©todo onCreate que √© chamado 
apenas uma vez durante seu ciclo de vida. Nesse momento a activity jecontra-se no estado de created,
onde ela foi criada mas ainda n√£o se encontra vis√≠vel para o usu√°rio.

- onStart(): Torna a activity vis√≠vel para o usu√°rio 
Quando o m√©todo onStart √© chamado a activity entra no estado de "Started", significa que ela pode 
estar vis√≠viel para o usu√°rio mas n√£o necessariamente em primeiro plano.

- onResume(): Coloca uma Activity em primeiro plano e interativa
O estado da activity nesse momento √© chamado de "Resumed", √© a retomada de uma activity.
Ela permanece nesse estado enuqanto encontra-se ativa.

- onPause(): Prepara√ß√£o para pausar uma activity
Caso outra activity entre em primeiro plano,  o m√©todo onPause()  √© chamado e a activity atual entra 
no estado de "Paused". Ela ainda continua vis√≠vel, por√©m n√£o se encontra mais no primeiro plano.

- onStop(): Activity n√£o mais vis√≠vel
A Activity entra no estado "Stopped", que significa que ela est√° completamente invisivel para
o usu√°rio por√©m ainda viva no sistema.

- onRestart(): Preparando para retomar uma activity

- onDestroy(): Limpeza final de uma activity
Uma activity pode entrar nesse estado tanto pela chamada do m√©todo finish() ou pelo pr√≥prio sistema
para recuperar recursos, ea entra no modo de "Destroyed", logo ap√≥s a chamada do m√©todo onDestroy().
Nesse momento ela √© removida da mem√≥ria, sendo totalmente destru√≠da.


## Navega√ß√£o entre activities

Um ponto importante sobre as activitys √© saber como funciona o seu gerenciamento, que ocorre baseado no conceito
de computa√ß√£o chamado LIFO (last in first out) ou Pilha, em Portugu√™s. Isso significa que a √∫ltima

Quando uma nova Activity √© iniciada, o sistema a coloca no topo da pilha de Activities do aplicativo.
Essa Activity se torna a Activity ativa - a Activity que o usu√°rio pode interagir.
Quando o usu√°rio pressiona o bot√£o de voltar, a Activity atual √© destru√≠da e removida do topo da pilha,
fazendo com que a Activity anterior na pilha se torne a Activity ativa. Se o usu√°rio continuar
pressionando o bot√£o de voltar at√© que a pilha de Activities esteja vazia, o aplicativo √© finalizado.

N√≥s usamos o m√©todo startActivity() para para abrir uma nova activity.
Esse m√©todo precisa receber uma Intent como par√¢metro, que traduzindo ao p√© da letra seria realmente 
uma inten√ß√£o de resolver ou fazer algo.

<img src='./assets/navegacaometodo.png '>

O primeiro par√¢metro corresponde a classe Intent que precisamos instanciar, que recebe um contexto,  
que √© um ponto de acesso as informa√ß√µes globais do seu app e como segundo par√¢metro recebe a classe
correspondente a tela que queremos navegar .


üëâ Conceitos importantes sobre esse gerenciamento de Pilhas

- Task e Back Stack:
Uma task √© um conjunto de activities,  qu eo usu√°rio vai interagir para executar uma a√ß√£o e cada tem
sua pr√≥pria pilha de activities, as back stacks.

- Multi-tarefa: O android permite que o usu√°rio navegue entre tarefas, na pr√°tica isso quer dizer que 
o usu√°rio pode sair de um aplicativo para iniciar ou retornar a outro e em seguida, voltar ao
aplicativo original, retomando a partir de onde parou. 

- Gerenciamneto de estado:
Os estado das Activities devem ser gerenciados adequadamente ao navegar entre as Activies,
especialmente considerando que o sistema pode destruir Activities em segundo plano para recuperar recursos.


## Como ocorre o gerenciamento de estados em uma activity - salvando e restaurando esse estado

- O gerenciamento de estado em uma Activity no Android √© crucial para preservar e restaurar o estado 
da interface do usu√°rio quando ocorrem eventos como rota√ß√µes de tela ou mudan√ßas de configura√ß√£o.
- Uma mudan√ßa na configura√ß√£o (por exemplo, rota√ß√£o do dispositivo) pode causar a destrui√ß√£o e 
reconstru√ß√£o da Activity, o que requer o uso de m√©todos como onSaveInstanceState() para manter o estado.
- Para dados mais complexos ou persistentes, considere o uso de bancos de dados locais 
(como Room para SQLite) ou SharedPreferences.

Essas pr√°ticas ajudam a garantir uma experi√™ncia consistente para o usu√°rio, preservando o estado da
interface do usu√°rio mesmo quando ocorrem eventos que afetam a vida da Activity.


### Principais m√©todos e t√©cnicas utilizadas para realizar esse gerenciamento:

Salvando Estado

1. onSaveInstanceState(Bundle outState)

- Este m√©todo √© chamado antes da Activity ser destru√≠da, dando a oportunidade de salvar informa√ß√µes importantes para um Bundle.
- Bundle √© um dicion√°rio para armazenar e transmitir informa√ß√µes de estado e objetos entre Activity.
- Voc√™ pode usar put m√©todos no Bundle para salvar dados primitivos ou objetos serializ√°veis.

Restaurando Estado

2. onCreate(Bundle savedInstanceState)

- Quando a Activity √© recriada ap√≥s uma mudan√ßa de configura√ß√£o, o Bundle savedInstanceState √© fornecido para restaurar o estado anterior.
- Verifique se savedInstanceState n√£o √© nulo antes de tentar restaurar valores, para evitar NullPointerException.

Ciclo de Vida

3. onRestoreInstanceState(Bundle savedInstanceState)

- Este m√©todo √© chamado depois de onStart() quando existe um estado salvo para ser restaurado, 
mas n√£o √© amplamente usado porque a restaura√ß√£o geralmente √© feita dentro de onCreate().

## Melhores pr√°ticas - Uso de Fragments para uma gest√£o flex√≠vel de UI

Um Fragment representa uma parte reutiliz√°vel da IU do seu app. Um fragmento define e gerencia o pr√≥prio layout, tem o pr√≥prio ciclo de vida e pode processar os pr√≥prios eventos de entrada. Os fragmentos n√£o podem existir sozinhos. Eles precisam ser hospedados por uma activity ou por outro fragmento. A hierarquia de visualiza√ß√£o do fragmento se torna parte da hierarquia de visualiza√ß√£o do host ou √© anexada a ela .

Os eventos b√°sicos do ciclo de vida de um Fragment s√£o muito semelhantes as de uma Activity. √Ä medida que o ciclo de vida executa os eventos como onStart, onResume, onPause e onStop, esses mesmos eventos ser√£o acionados dentro do pr√≥prio Fragment, sendo assim poss√≠vel mover a implementa√ß√£o feita nesses eventos da Activity para o Fragment sem muitos problemas.

### Ciclo de vida de um Fragment

- onCreate View
Ao inv√©s de construir sua interface no onCreate, utilizamos o evento onCreateView do Fragment para isso. O onCreateView √© onde voc√™ constr√≥i ou 
infla sua interface, faz conex√£o com alguma fonte de dados e retorna √† Activity pai para poder integr√°-lo em sua hierarquia de Views.

- onDestroyView
O onDestroyView √© correspondente ao onDestroy da Activity e √© chamado imediatamente antes do Fragment ser destruido. Ele funciona 
independente da Activity pai. Aqui √© onde voc√™ deve limpar quaisquer recursos especificamente relacionados √† interface, 
como bitmaps na mem√≥ria, cursores de dados, para garantir que n√£o haja problemas de mem√≥ria.

- onAttach
O onAttach √© onde podemos obter uma refer√™ncia para a Activity pai.

- onDetach
O onDetach √© a √∫ltima coisa que acontece no ciclo de vida, mesmo ap√≥s o seu Fragment ser tecnicamente destru√≠do.

- onActivityCreated
Isso notifica nosso Fragment que a Activity pai completou seu ciclo no onCreate e √© aqui que podemos interagir com seguran√ßa com a interface de usu√°rio.

- onStop
Assim como no ciclo de vida da Activity, uma vez que o Fragment n√£o est√° mais vis√≠vel, h√° uma chance dele ser encerrado. Isso pode acontecer,
ap√≥s o onStop, no caso de a Activity ser encerrada, pois o Fragment faz parte da sua hierarquia de Views ou ap√≥s o onDestroyView.

#### Como criar um Fragment?

1. Crie uma nova classe de fragmento:
Para criar um Fragment voc√™ precisa estender a classe Fragment ou uma de suas subclasses. As subclasses mais comuns utilizadas s√£o, por exemplo, ListFragment, 
DialogFragment ou PreferenceFragmentCompat. Dentro dessa classe, sobrescreva o m√©todo onCreateView para definir o layout do fragmento.

2. Crie o layout do fragmento:
Crie um arquivo XML no diret√≥rio res/layout para definir o layout do fragmento. Esse arquivo conter√° os elementos da interface que voc√™ deseja exibir no fragmento.

3. Adicione o fragmento √† atividade:
No layout da atividade (por exemplo, activity_main.xml), adicione um FrameLayout ou outro cont√™iner onde o fragmento ser√° inserido.

4. Inicie o fragmento na atividade:
No c√≥digo da atividade, use o FragmentManager para adicionar o fragmento ao cont√™iner definido no layout da atividade. Isso √© feito 
criando uma transa√ß√£o de fragmento e comprometendo-a.

##### Comunica√ß√£o do Fragment

Para reutilizar fragmentos, crie-os como componentes independentes que definem seu pr√≥prio layout e comportamento. Depois de definir esses fragmentos reutiliz√°veis, voc√™ pode associ√°-los a uma atividade e conect√°-los √† l√≥gica do aplicativo para criar a interface completa.
Para aumentar a reutiliza√ß√£o dos Fragments, eles nunca devem se comunicar diretamente uns com os outros. Toda comunica√ß√£o deve ser feita atrav√©s da Activity pai. Para isso, 
um Fragment deve definir uma Interface interna. O Fragment requer que a Activity, que o usa, implemente essa Interface. Desta forma voc√™ evita que o Fragment fique dependente da Acitivty que o usa.

No m√©todo onAttach(), voc√™ deve verificar se a Activity implementa corretamente essa Interface. Por exemplo, suponha que voc√™ tenha um Fragment que precise se comunicar com outro Fragment ou com sua Activity pai quando um determinado item √© selecionado, primeiro voc√™ defini uma Interface internamente no Fragment e implementa o m√©todo onAttach() para guardar uma inst√¢ncia da Interface e verificar a compatibilidade, e depois voc√™ deve implementar essa Interface na Activity.

A biblioteca Fragment oferece duas op√ß√µes de comunica√ß√£o: um ViewModel compartilhado e a API Fragment Result. A op√ß√£o recomendada depende do caso de uso. Para compartilhar dados persistentes com APIs personalizadas, use um ViewModel. Para conferir um resultado √∫nico com dados que podem ser colocados em um Bundle, use a API Fragment Result.

###### Transa√ß√µes do Fragment 

Durante a execu√ß√£o, o FragmentManager pode adicionar, remover, substituir e realizar outras a√ß√µes com fragments em resposta √† intera√ß√£o do usu√°rio. Cada conjunto de mudan√ßas confirmado √© chamado de transa√ß√£o. Voc√™ pode definir o que ser√° feito na transa√ß√£o usando as APIs da classe FragmentTransaction. V√°rias a√ß√µes podem ser agrupadas em uma √∫nica transa√ß√£o. Por exemplo, uma transa√ß√£o pode adicionar ou substituir v√°rios fragments ao mesmo tempo. Isso √© √∫til quando h√° v√°rios fragments exibidos na mesma tela, como em visualiza√ß√µes divididas.

Al√©m disso, cada transa√ß√£o pode ser salva em uma pilha de retorno gerenciada pelo FragmentManager, permitindo que o usu√°rio volte para as mudan√ßas de fragments anteriores, semelhante √† navega√ß√£o entre atividades.

Para obter uma inst√¢ncia de FragmentTransaction do FragmentManager, basta chamar beginTransaction().

## Conclus√£o
Neste trabalho, abordamos a implementa√ß√£o de Activities no Android com Kotlin. Explicamos como uma Activity
combina arquivos Kotlin e XML para formar a interface do usu√°rio e destacamos os principais m√©todos do ciclo de vida
(onCreate(), onStart(), onResume(), onPause(), onStop(), onRestart(), onDestroy()) que permitem gerenciar seu estado.

Tamb√©m discutimos a navega√ß√£o entre Activities usando Intents e o conceito de pilha de atividades.
Al√©m disso, exploramos t√©cnicas para salvar e restaurar estados da Activity durante mudan√ßas de configura√ß√£o.

E, por fim, ainda aprendemos a visualizar essas etapas do ciclo de vida atrav√©s dos logs.

## Informa√ß√µes gerais sobre o projeto

- N√≥s realizamos o b√°sico necess√°rio para visualizar alguns contextos abordados neste ReadMe
- Para observar o ciclo de vida das activities realizamos a sobrescrita dos m√©todos chamados nesse processo 
executando apenas Info logs.
- Podemos observar tamb√©m a execu√ß√£o e declara√ß√£o do m√©todo necess√°rio para navega√ß√£o entre activities.
- Voc√™ pode baixar e executar tranquilamente na sua m√°quina, verificando os pontos acima.


## Refer√™ncias de estudo

1. [Curso Udemy]https://www.udemy.com/course/desenvolvimento-android-completo/
2. [O que √© uma activity?]https://www.youtube.com/watch?v=9Y2KBJFZLZs
3. [ciclo de vida de uma activity]https://www.youtube.com/watch?v=dJ1U6MzEwKA
4. [imagem do ciclo de vida]https://pt.slideshare.net/slideshow/ciclo-de-vida-de-uma-activity/16390547
5. [Documenta√ß√£o oficial android]https://developer.android.com/codelabs/basic-android-kotlin-compose-activity-lifecycle?hl=pt-br#0
6. [Fragment]https://developer.android.com/guide/fragments?hl=pt-br
